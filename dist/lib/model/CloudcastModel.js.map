{"version":3,"file":"CloudcastModel.js","sourceRoot":"","sources":["../../../src/lib/model/CloudcastModel.ts"],"names":[],"mappings":"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","sourcesContent":["import mcfetch, { Cloudcast, PlaylistAPI, SearchAPI, SearchAPIGetShowsParams, UserAPI, UserAPIGetShowsParams } from 'mixcloud-fetch';\nimport mixcloud from '../MixcloudContext';\nimport BaseModel, { CommonModelPaginationParams, LoopFetchResult, OptionBundle } from './BaseModel';\nimport EntityConverter from '../util/EntityConverter';\nimport { CloudcastEntity } from '../entities/CloudcastEntity';\n\nexport type GetCloudcastsType = 'byUser' | 'byPlaylist' | 'bySearch';\n\n// Only available when fetching by user\nexport type CloudcastOrderby = NonNullable<UserAPIGetShowsParams['orderBy']>;\n\n// Only available for searches\nexport type CloudcastDateUploaded = NonNullable<SearchAPIGetShowsParams['dateUploaded']>;\n\nexport interface CloudcastSearchOptionValues {\n  dateUploaded: CloudcastDateUploaded;\n}\n\nexport type CloudcastModelGetCloudcastsParams =\n  CommonModelPaginationParams & ({\n    username: string;\n    orderBy?: CloudcastOrderby;\n    playlistId?: undefined;\n    keywords?: undefined;\n    dateUploaded?: undefined;\n  } | {\n    playlistId: string;\n    username?: undefined;\n    keywords?: undefined;\n    orderBy?: undefined;\n    dateUploaded?: undefined;\n  } | {\n    keywords: string;\n    dateUploaded?: CloudcastDateUploaded;\n    username?: undefined;\n    playlistId?: undefined;\n    orderBy?: undefined;\n  });\n\ntype GetCloudcastsParamsByType<T extends GetCloudcastsType> =\n  CommonModelPaginationParams &\n  (\n    T extends 'byUser' ? {\n      getType: 'byUser';\n      username: string;\n      orderBy?: CloudcastOrderby;\n    } :\n    T extends 'byPlaylist' ? {\n      getType: 'byPlaylist';\n      playlistId: string;\n    } :\n    T extends 'bySearch' ? {\n      getType: 'bySearch';\n      keywords: string;\n      dateUploaded?: CloudcastDateUploaded;\n    } :\n    never\n  );\n\nexport type GetCloudcastsFetchResult<T extends GetCloudcastsType> =\n  T extends 'byUser' ? NonNullable<Awaited<ReturnType<UserAPI['getShows']>>> :\n  T extends 'byPlaylist' ? NonNullable<Awaited<ReturnType<PlaylistAPI['getShows']>>> :\n  T extends 'bySearch' ? NonNullable<Awaited<ReturnType<SearchAPI['getShows']>>> :\n  never;\n\nexport interface GetCloudcastsLoopFetchResult<T extends GetCloudcastsType> extends LoopFetchResult<CloudcastEntity> {\n  params: GetCloudcastsFetchResult<T>['params'];\n}\n\nexport default class CloudcastModel extends BaseModel {\n\n  getCloudcasts(params: CloudcastModelGetCloudcastsParams & { username: string }): Promise<GetCloudcastsLoopFetchResult<'byUser'>>;\n  getCloudcasts(params: CloudcastModelGetCloudcastsParams & { playlistId: string }): Promise<GetCloudcastsLoopFetchResult<'byPlaylist'>>;\n  getCloudcasts(params: CloudcastModelGetCloudcastsParams & { keywords: string }): Promise<GetCloudcastsLoopFetchResult<'bySearch'>>;\n  getCloudcasts(params: CloudcastModelGetCloudcastsParams) {\n    if (params.username) {\n      return this.#getCloudcastsByType({\n        getType: 'byUser',\n        ...params\n      });\n    }\n    if (params.playlistId) {\n      return this.#getCloudcastsByType({\n        getType: 'byPlaylist',\n        ...params\n      });\n    }\n    if (params.keywords) {\n      return this.#getCloudcastsByType({\n        getType: 'bySearch',\n        ...params\n      });\n    }\n    throw Error('getCloudcasts() error: invalid params');\n  }\n\n  async #getCloudcastsByType<T extends GetCloudcastsType>(params: GetCloudcastsParamsByType<T>) {\n    const result = await this.loopFetch({\n      callbackParams: { ...params },\n      getFetchPromise: this.#getCloudcastsFetchPromise.bind(this),\n      getItemsFromFetchResult: this.#getCloudcastsFromFetchResult.bind(this)<T>,\n      getNextPageTokenFromFetchResult: this.#getNextPageTokenFromCloudcastsFetchResult.bind(this),\n      convertToEntity: this.#convertFetchedCloudcastToEntity.bind(this),\n      onEnd: this.#onGetCloudcastsLoopFetchEnd.bind(this)<T>,\n      pageOffset: params.pageOffset,\n      pageToken: params.pageToken,\n      limit: params.limit\n    });\n\n    this.cacheCloudcasts(result.items);\n\n    return result;\n  }\n\n  #getCloudcastsFetchPromise<T extends GetCloudcastsType>(params: GetCloudcastsParamsByType<T>): Promise<GetCloudcastsFetchResult<T>>;\n  #getCloudcastsFetchPromise<T extends GetCloudcastsType>(params: GetCloudcastsParamsByType<T>) {\n    const cacheParams: Record<string, any> = {\n      limit: params.limit,\n      pageToken: params.pageToken\n    };\n    if (params.getType === 'byUser') {\n      cacheParams.username = params.username;\n      cacheParams.orderBy = params.orderBy;\n    }\n    else if (params.getType === 'byPlaylist') {\n      cacheParams.playlistId = params.playlistId;\n    }\n    else if (params.getType === 'bySearch') {\n      cacheParams.keywords = params.keywords;\n      cacheParams.dateUploaded = params.dateUploaded;\n    }\n\n    return mixcloud.getCache().getOrSet(\n      this.getCacheKeyForFetch('cloudcasts', cacheParams),\n      async () => {\n        const paginationParams = {\n          limit: params.limit,\n          pageToken: params.pageToken\n        };\n        switch (params.getType) {\n          case 'byUser':\n            const fetchedByUser = await mcfetch.user(params.username).getShows({\n              orderBy: params.orderBy,\n              ...paginationParams\n            });\n            if (!fetchedByUser) {\n              throw Error(`User '${params.username}' not found`);\n            }\n            return fetchedByUser;\n\n          case 'byPlaylist':\n            const fetchedByPlaylist = await mcfetch.playlist(params.playlistId).getShows(paginationParams);\n            if (!fetchedByPlaylist) {\n              throw Error(`Playlist #${params.playlistId} not found`);\n            }\n            return fetchedByPlaylist;\n\n          case 'bySearch':\n            return await mcfetch.search(params.keywords).getShows({\n              dateUploaded: params.dateUploaded,\n              ...paginationParams\n            });\n        }\n      });\n  }\n\n  #getCloudcastsFromFetchResult<T extends GetCloudcastsType>(result: GetCloudcastsFetchResult<T> | null) {\n    if (!result) {\n      return [];\n    }\n    return result.items.slice(0);\n  }\n\n  #getNextPageTokenFromCloudcastsFetchResult<T extends GetCloudcastsType>(result: GetCloudcastsFetchResult<T> | null) {\n    return result?.nextPageToken && result.items.length > 0 ? result.nextPageToken : null;\n  }\n\n  #convertFetchedCloudcastToEntity(item: Cloudcast): CloudcastEntity {\n    return EntityConverter.convertCloudcast(item);\n  }\n\n  #onGetCloudcastsLoopFetchEnd<T extends GetCloudcastsType>(result: LoopFetchResult<CloudcastEntity>, lastFetchResult: GetCloudcastsFetchResult<T>): GetCloudcastsLoopFetchResult<T> {\n    return {\n      ...result,\n      params: lastFetchResult.params\n    };\n  }\n\n  getCloudcast(cloudcastId: string) {\n    return mixcloud.getCache().getOrSet(\n      this.getCacheKeyForFetch('cloudcast', { cloudcastId }),\n      async () => {\n        const data = await mcfetch.cloudcast(cloudcastId).getInfo();\n        return data ? this.#convertFetchedCloudcastToEntity(data) : null;\n      });\n  }\n\n  getSearchOptions(): OptionBundle<CloudcastSearchOptionValues> {\n    return {\n      dateUploaded: {\n        name: mixcloud.getI18n('MIXCLOUD_SELECT_DATE_UPLOADED'),\n        icon: 'fa fa-calendar',\n        values: [\n          { name: mixcloud.getI18n('MIXCLOUD_PAST_WEEK'), value: 'pastWeek' },\n          { name: mixcloud.getI18n('MIXCLOUD_PAST_MONTH'), value: 'pastMonth' },\n          { name: mixcloud.getI18n('MIXCLOUD_PAST_YEAR'), value: 'pastYear' },\n          { name: mixcloud.getI18n('MIXCLOUD_ANY_TIME'), value: 'anyTime' }\n        ]\n      }\n    };\n  }\n}\n"]}